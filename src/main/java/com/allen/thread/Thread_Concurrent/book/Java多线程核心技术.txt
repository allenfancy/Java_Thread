Java并发线程核心编程：

**要编写正确的并发程序，关键的问题：在访问共享的可变状态时需要进行正确的管理**
====================================
一、线程安全性
Tips:如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现问题，可以通过以下三种方式进行修复
	 不在线程之间共享状态变量
	 将状态变量修改为不可变的变量
	 在访问状态变量时使用同步
	 当设计线程安全的类时，良好的面向对象技术、不可修改性，以及清晰明了的不变性规范都能起到一定的帮助作用。
	 无状态对象一定是线程安全的
大多数的Servlet都是无状态的，从而降低了实现Servlet线程安全性时的复杂程度。只有当Servlet在处理请求时需要保存一些信息，线程安全性才会成为一个问题
1.原子性：
	++count：这个操作看似只有一个操作，但这个操作并非原子性的。实际上这是三个操作：读取count的值，加1，然后在赋值给count，其结果状态依赖于之前的状态

2.竞态条件：
	当某个计算的正确性取决于多个线程的交替执行时，那么就会发生竞态条件。最常见的竞态条件类型就是『先检查后执行』操作，即通过一个可能失效的观测结果来决定下一步操作
	在实际情况中，应该尽可能地使用现有的线程安全对象(例如:AcomicLong)来管理类的状态。与非线程安全的对象相比，判断安全对象的可能状态及其状态转换情况要更为容易，从而也更容易维护和验证线程的安全性

3.加锁机制
	当在Servlet中添加一个状态变量时，可以通过现场安全的对象来管理Servlet的状态以维护Servlet的线程安全性。
	要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。
  3.1内置锁
  	 Java提供一种内置的锁机制来支持原子性：同步代码块(Synchronized Block).同步代码块包含俩个部分：一个是作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字synchronized来修饰的方法就是一种
  	 横跨珍格格方法体的统统不代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以Class对象作为锁。
  	 synchronize(lock){
  	 	//访问或修改由锁保护的共享状态
  	 }
  	 Java内置锁相当于一种互斥锁，最多只能有哦一个线程能持有这个锁。
  3.2重入
  	 当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程视图获得一个已经由它自己持有的锁，那么这个请求就会成功。
  	 重入意味着获取锁的操作的粒度是"线程"，而不是"调用"。重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并将获取计数值设置为1.
4.用锁来保护状态
	由于所能使其保护的代码路径以串行形式来访问，因此可以通过所来构造一些协议以是实现对共享状态的独立访问。
	对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下， 我们称状态变量是由这个锁保护的。
	对象的内置锁于其状态之间没有内在的关联。虽然大多数类都将内置锁用做一种有效的加锁机制，但对象的域并不一定要通过内置锁来保护。
	每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。

二、对象的共享
    同步代码块和同步方法可以确保以原子的方式执行操作，但一种常见的误解：认为关键字synchronized只能用于实现原子性或者确定"临界区()".同步另一个重要方面是:内存可见性(Memeory Visibility).
    只要有数据在多个线程之间共享，就使用正确的同步。
    加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步
  1.Volatile变量
  	Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。
  	volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值
  	加锁机制即可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。
    当满足一下所有条件时，才应该使用volatile变量:
    。对变量的写入操作不依赖变量的当前值(count++),或者你能确保只有单个线程更新变量的值
    。该变量不会与其他状态变量一起纳入不变行条件中。
    。在访问变量时不需要加锁
  2.发布与逸出
  	 发布一个对象的意思是指：使对象能够在当前作用域之外的代码中使用。例如：将一个指向该对象的引用保存到其他代码可以访问的地方，或者在某一个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。
  	 在许多的情况下，我们又需要发布某个对象，但如果在发布时要确保线程安全性，则可能需要同步。发布内部状态可能会破坏封装性，并使得程序难以维护不变行条件。
  	 当某个不该发布的对象被发布时，这种情况就被称为逸出。
  	 发布对象的最简单的方法是将对象的引用保存到一个公共的静态变量中，以便任何类和线程都能看见该对。
  	 public static Set<Object> knownObjects;
  	 public void initialize(){
  	 	knownObjects = new HashSet<Object>();
  	 }
	 安全的对象构造过程：
	 	
  3.线程封闭
  	 当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术称为线程封闭，它是实现线程安全性的最简单的方式之一。
  	 在Java Swing中大量使用了线程封闭，Swing的可视化组件和数据模型对象都不是线程安全的，Swing通过将它们封闭到Swing的事件分发线程中来实现线程安全性。
    1.Ad-hoc线程封闭
    	Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。Ad-hoc线程封闭非常脆弱的，因为没有任何一种语言特性，例如可见行修饰符或局部变量，能将对象封闭到目标线程上。
	 
	2.ThreadLocal类
		维持线程封闭性的一种更规范方法。这个类能是线程中的某个值与保持值的对象关联起来。ThreadLocal提供了get和set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值
		ThreadLocal对象通常用于放置对象可变的单例变量或者全局变量进行共享。
		不可变对象一定是线程安全的
		对象创建以后其状态就不能改变
		对象的所有域都是final类型
		对象是正确创建的（在对象创建期间，this引用没有逸）
  4.安全发布的常用模式
  	  可变对象必须通过安全的方式来发布，这通常意味着在发布和使用该对象的线程时都必须使用同步。
  	  要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全发布：
  	  	1.在静态初始化函数中初始化一个对象引用。
  	  	2.将对象的引用保存到volatile类型的域或者AtomicReferance对象中。
  	  	3.将对象的引用保存到某个正确构造对象的final类型域中。
  	  	4.将对象的引用保存到一个由锁保护的域中
  	  安全地共享对象
  	  	当获得对象的一个引用时，您需要知道这个引用上可执行那些操作。在使用它之前是否要获得一个锁？是否可以修改它的状态，或者只能读它？
  	  	在并发程序中使用和共享对象时，可以使用一些策略：
  	  	线程封闭：线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并只能由这个线程修改。
  	  	只读共享：在没有额外同步的情况下，共享的只读对象可以有多个线程并发访问，但任何线程都不能修改他们，共享的只读对象包括不可变对象和事实不可变的对象
  	  	线程安全共享：线程安全的对象在其背部实现同步，因此多个线程可以通过对象的共有接口来进行访问而不需要进一步的同步。
  	  	保护对象：被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及发布的并且由某个特定锁保护的对象
	 
	 
	 
	 
三、对象的组合
  1.设计线程安全的类
  	在线程安全的程序中，虽然可以将程序的所有状态保存到公用的静态域中，但与那些将状态封装起来的程序比，这些程序还是难以得以验证，并在修改时，也更难一致保持线程的安全性。通过封装激素，可以使得在不对整个程序进行分析的情况下就可以判断一个类是否线程安全。
  	在设计线程安全类的过程中，需要包含以下三个基本要点：
  		找出构成对象状态的所有变量
  		找出约束状态变量的不变行条件
  		建立对象状态的并发访问管理策略
    将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。
    封闭机制更容易构造线程安全的类，因为当封闭类的装填时，在分析类的线程安全性的时候，就无需检测整个程序
    正如封装对象的状态有助于维持不变性条件一样，封装对象的同步机制同样有助于确保实施同步策略
  2.并发容器
  	同步容器将所有对容器状态访问都串行化，以实现他们的线程安全性。这种方式的代价是严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重减低。
  	并发容器是针对多个线程并发访问设计的，例如：ConcurentHashMap,用来代替同步且基于散列的Map。以及CopyOnWriteArrayList，用于遍历操作为主要操作的情况下代替同步的List。
  	在新的ConcurrentMap接口中增加了对一些常见符合操作的支持。例如：若没有则添加、替换以及有条件删除等。
  	通过并发容器来替代同步容器，可以及大地提高伸缩性并降低风险。
  	在JDK5.0增加俩个新的容器类型：Queue和BlockingQueue
  	Queue是用来临时保存一组等待处理的元素。它提升了几种实现，包括：ConcurrentLinkedQueue，这是先进先出的队列，以及PriorityQueue。这是一个(非并发的)优先队列。
  	Queue的操作不会阻塞，如果队列为空，那么获取元素的操作将返回空值。
  	BlockingQueue扩展了Queue，增加了可阻塞的插入和获取等操作。如果队列为空，那么获取元素的操作将一直阻塞，知道队列中出现一个可用的元素，直到队列中出现一个可用元素。如果队列已满，那么插入元素的操作将一直阻塞，知道队列中出现可用的空间。
  	在"生产者-消费者"这种设计模式中，阻塞队列是非常有用的。
  	Java 6也引入了ConcurrentSkipListMap和ConcurrentSkipSet，分别作为同步的SortedMap和SortedSet的并发代替品。例如用synchronizedMap包装的TreeMap或TreeSet
   1.ConcurrentHashMap
   	  同步容器类在执行每个操作期间都持有一个锁。
   2.CopyOnWriteArrayList
   	  CopyOnWriteArrayList用于代替同步List，在某些情况下它提供了更好的并发性能，并且在迭代期间不需要对容器进行加锁或复制。
   	  在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制并防止生产过多的工作项，是应用程序在负荷过载的情况下变得更加健壮
   	  最后一个BlockingQueue实现SynchronousQueue，实际上它不是一个真正的队列，因为他不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程等待着把元素加入或移除队列。
   	  
 小结：
 	可变状态是至关重要的。
 		所有的并发问题都可以归为如何协调对并发状态的访问。可变状态越少，就越容易确保线程安全性。
 	尽量将域声明为final类型，除非需要它们是可变的
 	不可变对象一定是线程安全
 		不可变对象能极大地降低并发编程的复杂性。它们更为简单而且安全可以任意共享而无须使用加锁或保护性复制等机制
 	封装有助于管理复杂性
 		在编写线程安全的程序时，虽然可以将所有数据都保存在全局变量中，但为毛要这么做呢？将数据封装在对象中，更易于维护不变性条件：将同步机制封装在对象中，更易于遵循同步策略
 	用锁来保护每个可变变量
 	当保护同一个不变性条件中的所有变量时，要使用同一个锁
 	在执行复合操作期间，要持有锁
 	如果从多个线程中访问同一个可变变量时没有同步机制，那么程序会出现问题。
 	不要故作聪明地推出不需要使用同步
 	在设计过程中考虑线程安全，或者在文档中明确地指出它不是线程安全的
 	将同步策略文档化
 	
 	
四、结构化并发应用程序
    Tips：调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息
    对中断操作的正确理解：它并不会正真地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己。wait.sleep，join等，将严格地处理这种请求，当它收到中断请求或者在开始执行时发现某个已被设置好的中断状态时，将抛出一个异常。
    通常，中断是实现取消的最合理方式
    由于每个线程拥有各自的中断策略，因此除非你知道中断对该线程的含义，否则就不应该中断这个线程。
    响应中断：
    	传递异常（可能在执行某个特定于热舞的清楚操作之后），从而使你的方法也成为可中断的阻塞方法。
    	恢复中断状态，从而使调用栈中的上传代码能够够对其进行处理
    对于持有线程的服务，只要服务的存在时间大于创建线程的方法的存在时间，那么就应该提供生命周期方法
 
五、线程池的使用
	每当提交了一个有依赖性的Executor任务时，要清楚地知道可能出现线程"饥饿"死锁，因此需要在代码或配置Executor的配置文件中记录线程池的大小限制或配置限制
	在有限的线程池中会限制可并发执行的任务数量
	